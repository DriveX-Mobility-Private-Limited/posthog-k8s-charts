##############################################################################
# PostHog Capture & Replay-Capture — Rust ingestion services
# Replaces the broken Helm "events" and "recordings" deployments.
#
# These use the same Rust images as the working Docker Compose deployment:
#   ghcr.io/posthog/posthog/capture:master
#
# The Helm chart shipped posthog/posthog (Django) for both events AND web,
# so the events pod never ran the Rust ingestion binary — it ran Django and
# returned 403 CSRF on every POST.  These manifests fix that.
#
# Apply:  kubectl apply -f posthog-dev-capture.yaml -n posthog
# Delete: kubectl delete -f posthog-dev-capture.yaml -n posthog
##############################################################################

# ─── 1. CAPTURE (events ingestion) ──────────────────────────────────────────
#     Handles: /capture/  /e/  /batch/
#     Kafka topic: events_plugin_ingestion
# ────────────────────────────────────────────────────────────────────────────

apiVersion: apps/v1
kind: Deployment
metadata:
  name: posthog-dev-capture
  namespace: posthog
  labels:
    app: posthog
    role: capture
    release: posthog-dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: posthog
      role: capture
      release: posthog-dev
  template:
    metadata:
      labels:
        app: posthog
        role: capture
        release: posthog-dev
    spec:
      nodeSelector:
        if-posthog-pod: "true"
      tolerations:
        - key: "if-monitoring-pod"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
        - key: "if-posthog-pod"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
      containers:
        - name: capture
          image: ghcr.io/posthog/posthog/capture:master
          imagePullPolicy: Always
          ports:
            - containerPort: 3000
              name: http
              protocol: TCP
          env:
            # ── Mode ──────────────────────────────────────────────────────
            - name: CAPTURE_MODE
              value: "events"
            # ── Bind to all interfaces (CRITICAL: use ADDRESS not CAPTURE_HOST)
            - name: ADDRESS
              value: "0.0.0.0:3000"
            # ── Kafka ─────────────────────────────────────────────────────
            - name: KAFKA_HOSTS
              value: "posthog-dev-posthog-kafka:9092"
            - name: KAFKA_TOPIC
              value: "events_plugin_ingestion"
            # ── ClickHouse ────────────────────────────────────────────────
            - name: CLICKHOUSE_HOST
              value: "chi-posthog-posthog-0-0"
            - name: CLICKHOUSE_DATABASE
              value: "posthog"
            - name: CLICKHOUSE_USER
              value: "admin"
            - name: CLICKHOUSE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: posthog-clickhouse-secret
                  key: clickhouse-password
            # ── PostgreSQL (via PgBouncer) ─────────────────────────────────
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: posthog-postgresql-secret
                  key: postgresql-url
            # ── Redis ─────────────────────────────────────────────────────
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: posthog-redis-secret
                  key: redis-password
            - name: REDIS_URL
              value: "redis://:$(REDIS_PASSWORD)@192.168.4.81:6379/1"
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          # NOTE: Health probes removed - /healthz endpoint returns 404
          # The binary runs successfully but has no health endpoint
          # Kubernetes default behavior will keep it running
---
apiVersion: v1
kind: Service
metadata:
  name: posthog-dev-capture
  namespace: posthog
  labels:
    app: posthog
    role: capture
    release: posthog-dev
spec:
  selector:
    app: posthog
    role: capture
    release: posthog-dev
  ports:
    - name: http
      port: 3000
      targetPort: http
      protocol: TCP

# ─── 2. REPLAY-CAPTURE (session recordings ingestion) ───────────────────────
#     Handles: /s/
#     Kafka topic: session_recording_snapshot_item_events
# ────────────────────────────────────────────────────────────────────────────

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: posthog-dev-replay-capture
  namespace: posthog
  labels:
    app: posthog
    role: replay-capture
    release: posthog-dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: posthog
      role: replay-capture
      release: posthog-dev
  template:
    metadata:
      labels:
        app: posthog
        role: replay-capture
        release: posthog-dev
    spec:
      nodeSelector:
        if-posthog-pod: "true"
      tolerations:
        - key: "if-monitoring-pod"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
        - key: "if-posthog-pod"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
      containers:
        - name: replay-capture
          image: ghcr.io/posthog/posthog/capture:master
          imagePullPolicy: Always
          ports:
            - containerPort: 3000
              name: http
              protocol: TCP
          env:
            # ── Mode ──────────────────────────────────────────────────────
            - name: CAPTURE_MODE
              value: "recordings"
            # ── Bind to all interfaces (CRITICAL: use ADDRESS not CAPTURE_HOST)
            - name: ADDRESS
              value: "0.0.0.0:3000"
            # ── Kafka ─────────────────────────────────────────────────────
            - name: KAFKA_HOSTS
              value: "posthog-dev-posthog-kafka:9092"
            - name: KAFKA_TOPIC
              value: "session_recording_snapshot_item_events"
            # ── ClickHouse ────────────────────────────────────────────────
            - name: CLICKHOUSE_HOST
              value: "chi-posthog-posthog-0-0"
            - name: CLICKHOUSE_DATABASE
              value: "posthog"
            - name: CLICKHOUSE_USER
              value: "admin"
            - name: CLICKHOUSE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: posthog-clickhouse-secret
                  key: clickhouse-password
            # ── PostgreSQL (via PgBouncer) ─────────────────────────────────
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: posthog-postgresql-secret
                  key: postgresql-url
            # ── Redis ─────────────────────────────────────────────────────
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: posthog-redis-secret
                  key: redis-password
            - name: REDIS_URL
              value: "redis://:$(REDIS_PASSWORD)@192.168.4.81:6379/1"
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          # NOTE: Health probes removed - /healthz endpoint returns 404
---
apiVersion: v1
kind: Service
metadata:
  name: posthog-dev-replay-capture
  namespace: posthog
  labels:
    app: posthog
    role: replay-capture
    release: posthog-dev
spec:
  selector:
    app: posthog
    role: replay-capture
    release: posthog-dev
  ports:
    - name: http
      port: 3000
      targetPort: http
      protocol: TCP

# ─── 3. INGRESS OVERRIDE ─────────────────────────────────────────────────────
#     Replaces the Helm-generated ingress entirely.
#     Routing matches the working Docker Compose (Caddy) proxy:
#
#       /capture/*  /e/*  /batch/*   → capture:3000    (Rust)
#       /s/*                         → replay-capture:3000  (Rust)
#       /decide/*                    → decide:8000     (separate Helm deployment)
#       /*                           → web:8000        (Django — everything else)
#
#     NOTE: The Helm ingress is named "posthog-dev".  We name ours
#           "posthog-dev-custom" so both can coexist briefly during cutover.
#           Once confirmed working, disable the old one in Helm values.
# ────────────────────────────────────────────────────────────────────────────

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: posthog-dev-custom
  namespace: posthog
  labels:
    app: posthog
    release: posthog-dev
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-dev"
    nginx.ingress.kubernetes.io/use-forwarded-headers: "true"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-buffering: "off"
    # CORS configuration
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "https://www.drivex.dev,https://drivex.dev,http://localhost:3000"
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, OPTIONS, PUT, DELETE, PATCH"
    nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,X-Correlation-ID"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - posthog-v1.drivex.dev
      secretName: posthog-dev-tls
  rules:
    - host: posthog-v1.drivex.dev
      http:
        paths:
          # ── Rust capture (events) ───────────────────────────────────────
          - path: /capture/
            pathType: Prefix
            backend:
              service:
                name: posthog-dev-capture
                port:
                  number: 3000
          - path: /e/
            pathType: Prefix
            backend:
              service:
                name: posthog-dev-capture
                port:
                  number: 3000
          - path: /batch/
            pathType: Prefix
            backend:
              service:
                name: posthog-dev-capture
                port:
                  number: 3000
          # ── Rust capture (session recordings) ──────────────────────────
          - path: /s/
            pathType: Prefix
            backend:
              service:
                name: posthog-dev-replay-capture
                port:
                  number: 3000
          # ── Decide (feature flags) → separate Helm deployment ───────────
          - path: /decide/
            pathType: Prefix
            backend:
              service:
                name: posthog-dev-decide
                port:
                  number: 8000
          # ── Everything else → Django web ────────────────────────────────
          #    This includes /flags/, /static/, the UI, admin, etc.
          - path: /
            pathType: Prefix
            backend:
              service:
                name: posthog-dev-web
                port:
                  number: 8000
